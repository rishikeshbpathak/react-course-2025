### Overview — concise notes and expanded information

1️⃣ Functional Components and Props (Function-based components, Props)
- What: Small functions that return JSX. Prefer them for most UI.
- Usage: Accept `props` or destructure props: `function Welcome({ name }) { ... }`.
- Notes: Props are read-only — do not mutate. Use default values or prop destructuring.
- Tip: Pass only necessary data and callbacks from parent to child.

2️⃣ State and Lifecycle (useState, useEffect)
- What: `useState` stores local component state; `useEffect` runs side effects (mount, update, cleanup).
- Patterns:
    - Init: `const [count, setCount] = useState(0);`
    - Effect on mount: `useEffect(() => { ... }, []);`
    - Effect on specific values: `useEffect(() => { ... }, [value]);` 
    - Cleanup: return a cleanup function for subscriptions/timeouts.
- Pitfalls: Avoid updating state synchronously during render; include correct dependencies to prevent stale closures or extra runs.

3️⃣ Handling Events (Events: click, change, submit)
- Syntax: Use camelCase handlers: `onClick`, `onChange`, `onSubmit`.
- Handler form: Pass a function reference or arrow: `<button onClick={handleClick}>`.
- Event object: React provides a synthetic event (`e`). If you need the native event asynchronously, capture the needed values or persist the event.
- Tip: No manual binding required in function components.

4️⃣ Conditional Rendering and Lists
- Conditional patterns:
    - Ternary: `{isLoggedIn ? <A /> : <B />}`
    - Short-circuit: `{show && <Component />}`
    - Helper functions: return different JSX from a render helper for complex logic.
- Lists: Use `array.map(item => <li key={item.id}>{item.name}</li>)`.
- Keys: Provide a stable, unique `key` (prefer an id). Avoid using array index as a key unless list is static.

5️⃣ Forms and Controlled Components
- Controlled inputs: Component state drives input values: `<input value={name} onChange={e => setName(e.target.value)} />`.
- Submit handling: Use `onSubmit` on `<form>` and `e.preventDefault()` to handle form logic in JS.
- Pattern: Use a single change handler for multiple fields by using `name` attributes and updating state accordingly.
- When to use uncontrolled: For simple or performance-sensitive use cases, consider refs/uncontrolled inputs.

Best practices (short)
- Keep components small and focused; lift state up only when needed.
- Prefer immutability for state updates.
- Use unique keys for lists to avoid rendering bugs.
- Clean up effects to avoid memory leaks.
- Profile and memoize (`React.memo`, `useCallback`, `useMemo`) only when needed.

See the example code blocks below this section for concrete implementations of each concept.

### Example

#### 1️⃣ Functional Components and Props
A simple function component that receives `props`.

```jsx
function Welcome(props) {
    return <h1>Hello, {props.name}!</h1>;
}

// Usage
<Welcome name="Aman" />
```

---

#### 2️⃣ State and Lifecycle in Functional Components (useState, useEffect)
Using `useState` for state and `useEffect` for side effects.

```jsx
import { useState, useEffect } from "react";

function Counter() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        console.log("Component mounted or updated!");
    }, [count]);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increase</button>
        </div>
    );
}
```

---

#### 3️⃣ Handling Events in React
Event handlers are passed as functions (camelCase).

```jsx
function ButtonExample() {
    function handleClick() {
        alert("Button clicked!");
    }

    return <button onClick={handleClick}>Click Me</button>;
}
```

---

#### 4️⃣ Conditional Rendering and Lists
Conditional rendering with ternary; lists rendered with `map()` and a `key`.

```jsx
function Greeting({ isLoggedIn }) {
    return isLoggedIn ? <h1>Welcome Back!</h1> : <h1>Please Log In</h1>;
}

function NameList() {
    const names = ["Aman", "Riya", "Neha"];
    return (
        <ul>
            {names.map((name, index) => (
                <li key={index}>{name}</li>
            ))}
        </ul>
    );
}
```

---

#### 5️⃣ Forms and Controlled Components
Inputs controlled via state; prevent default on submit.

```jsx
import { useState } from "react";

function FormExample() {
    const [name, setName] = useState("");

    function handleSubmit(e) {
        e.preventDefault();
        alert("Submitted name: " + name);
    }

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
            />
            <button type="submit">Submit</button>
        </form>
    );
}
```
